# 1
### 输出 10
#### 解析： for循环中，给a添加了10个
```js 
function () { console.log(i) }
```
#### 此上下文中并没有 `i` 所以他会去拿全局的 `i` ， 此时 `i=10` ，所以 `a[6]()` 输出10

#### 若将原代码改为：
```js
var a = []
for (let i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
```
#### 那么 `a[6]()` 将会输出6，因为此时 `i` 为块级作用域，其不会随 `for循环` 而改变到当前作用域中的值


# 2
### 执行会报，`tmp` 在声明前使用的错，
#### 因为当前作用域中有`let tmp`， 在代码块中，`tmp`在声明之前，都是不可使用的，也称 <b>“暂时性死区”</b> 

# 3
```js
var arr = [12, 34, 32, 89, 4]
arr.reduce((per, cur) => per > cur ? cur : per) // 4
```

# 4
#### 相比var； let 和 const 有一下特点
1. 存在一种叫做块级作用域的东西，
2. 不可以变量提升
3. 在声明之前不可以使用
4. 同一作用域下不可同时声明

#### 而const 相比 let， const 创建的是一个只读的值，声明之后不可被修改，`此处所讲的修改是不能修改其内存地址`，表现为不可重新赋值，但是引用类型下，可以修改其内部的值，例如
```js
const a = {}
a['ab'] = 1 // 不会报错
```

# 5
### obj.fn() 输出20
#### 箭头函数中的this，指向他当前执行环境的宿主对象。
#### `obj.fn()` 中，`fn()` 的执行环境是`obj`， 所以，箭头函数中的`this`，为`obj`

# 6
### `Symbol` 意为符号，且生成的类型是独一无二的，其主要作用就是为对象添加独一无二的属性名，有效解决私有属性被外部访问或修改到
#### `const obj = {[Symbol.toStringTag]: 'XXXObject'}`, 会修改对象的类型(`[object XXXObject]`) **迭代器会用到**
#### 对象中若key为`Symbol`, for...in... Object.keys(), JSON.stringfy()都是拿不到该key的，使用`Object.getOwnPorpertySymbols(obj)` 会获取到所有的Symobl()

# 7
### **浅拷贝**就是复制一个对象，但是新对象使用的内存地址和原对象是一致的，将会导致修改一个对象的属性值，另一个对象也会被改变
#### 常用Object.assign
### **深拷贝**是在浅拷贝的基础上，同时开辟一个新的内存地址，
#### 常用JSON.parse(JSON.stringfy) 但是该方式无法拷贝对象中原型链上的属性，且无法拷贝对象中的函数
#### 但JSON的方式不足以满足时，将采用递归的方式，并判断每种属性的类型，对其做特殊的处理，具体可参考`loadsh`

# 8
#### 早期的前端，大部分是在处理浏览器的dom，由于执行方式比较简单，且不增加额外的复杂性，所以JS设计的初衷是单线程的，但是后来JS越来越复杂，出现很多有可能阻塞线程的操作，所以JS为这些任务新增了异步的方式，并通过运行栈来对其进行管理
#### 早期，通过回调的方式，来解决异步编程（例如JsonP 这种处理跨域的方式）,但太多的回调嵌套，会降低代码易读性，所以在新的ECMAScript加入了Promise和async 

#### JS执行任务时js会判断该任务是同步任务还是异步任务，同步任务会直接执行，为防止阻塞主线程，异步任务会放到另一个**任务队列**中单独执行
#### 当异步任务队列中的异步任务执行完毕，并不会立即放到主线程中执行，而是会等待主线程中执行完当前栈中的任务，空闲下来后，回去异步任务队列中取最前面的任务，并同步执行，之后取下一个任务，如此循环的过程就叫 `Event Loop`

#### 常见宏任务有setTimeout，setInterview，微任务有Promise
#### 异步任务执行时，遇到宏任务，会放入其放入Event Loop中执行，执行过程中，遇到`Promise`，并且该Promise已经有结果（非pending）,此时会产生一个微任务，同时将该微任务放入微任务队列，在执行完当前宏任务后，依次执行微任务，如果执行微任务的时候又遇到了微任务，则会将新的微任务添加到微任务队列的尾部，当所有的微任务执行完后，会执行下一个宏任务

# 9
```js
function a () {
    return new Promise(resovle => {
        setTimeout(() => {
            resovle('hellow')
        }, 10)
    })
}

function b (prev) {
    return new Promise(resovle => {
        setTimeout(() => {
            resovle(prev + 'lagou')
        }, 10)
    })
}

function c (prev) {
    return new Promise(resovle => {
        setTimeout(() => {
            resovle(prev + 'aaa')
        }, 10)
    })
}

a()
.then(a1 => b(a1))
.then(b1 => c(b1))
.then(res => {
    console.log(res)
})

```

# 10 
#### JS是一门静态语言，不需要部署到服务器，放在浏览器或node环境可以直接运行，同时也是一门弱类型语言，存在很多的隐式类型转换
#### TS主要增强了JS的静态类型检查，虽然没有JAVA那么强大，但TS能够帮我们early fail, 在开发编译阶段就找到隐藏的问题，而不是部署之后，同时IDE插件的帮我们做类型推断，还能增加代码可读性

# 11 
### 优点
* 让代码更规范，同时书写起来也比较舒服，可以做到代码即文档。
* 大型项目中使用，对于后期的重构也能带来更多的便利。
* 另外在写一些第三方库的时候，可以方便使用者了解各个API的用法。
### 缺点
* 需要写很多额外的代码，用惯了弱类型的人，会花很多的时间想这个值到底该是什么类型，`string|number|null`，写着写着就any一把梭了。
* 将会花时间去解决TS的报错，特别是刚上手的人，一报错，又看不懂，只能是去搜索，或者疯狂尝试。
* 还有一点TS只是做了静态类型检查，并不是将JS包装成强语言，所以有时候代码报错但不影响运行，或是语法上没问题了，但是运行时会有问题。这算是一个优点也算一个缺点吧。