# 1
### 输出 10
#### 解析： for循环中，给a添加了10个
```js 
function () { console.log(i) }
```
#### 此上下文中并没有 `i` 所以他会去拿全局的 `i` ， 此时 `i=10` ，所以 `a[6]()` 输出10

#### 若将原代码改为：
```js
var a = []
for (let i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
```
#### 那么 `a[6]()` 将会输出6，因为此时 `i` 为块级作用域，其不会随 `for循环` 而改变到当前作用域中的值


# 2
### 执行会报，`tmp` 在声明前使用的错，
#### 因为当前作用域中有`let tmp`， 在代码块中，`tmp`在声明之前，都是不可使用的，也称 <b>“暂时性死区”</b> 

# 3
```js
var arr = [12, 34, 32, 89, 4]
arr.reduce((per, cur) => per > cur ? cur : per) // 4
```

# 4
#### 相比var； let 和 const 有一下特点
1. 存在一种叫做块级作用域的东西，
2. 不可以变量提升
3. 在声明之前不可以使用
4. 同一作用域下不可同时声明

#### 而const 相比 let， const 创建的是一个只读的值，声明之后不可被修改，`此处所讲的修改是不能修改其内存地址`，表现为不可重新赋值，但是引用类型下，可以修改其内部的值，例如
```js
const a = {}
a['ab'] = 1 // 不会报错
```

# 5
### obj.fn() 输出20
#### 箭头函数中的this，指向他当前执行环境的宿主对象。
#### `obj.fn()` 中，`fn()` 的执行环境是`obj`， 所以，箭头函数中的`this`，为`obj`